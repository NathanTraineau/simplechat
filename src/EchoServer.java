// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import java.io.*;import ocsf.server.ConnectionToClient;import common.ChatIF;import ocsf.server.*;/** * This class overrides some of the methods in the abstract  * superclass in order to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer extends AbstractServer {	ServerConsole serverCons;	ChatIF serverUI;  //Class variables *************************************************    /**   * The default port to listen on.   */  final public static int DEFAULT_PORT = 5555;    //Constructors ****************************************************    /**   * Constructs an instance of the echo server.   *   * @param port The port number to connect on.   */  public EchoServer(int port, ServerConsole serverCons)   {	  super(port);	 this.serverCons = serverCons;	 try {		this.listen();	} catch (IOException e) {		// TODO Auto-generated catch block		System.out.println("server can't listen");	}      }    //Instance methods ************************************************        /**   * This method overrides the one in the superclass.  Called   * when the server starts listening for connections.   */  protected void serverStarted()  {    System.out.println      ("Server listening for connections on port " + getPort());  }    /**   * This method overrides the one in the superclass.  Called   * when the server stops listening for connections.   */  protected void serverStopped()  {    System.out.println      ("Server has stopped listening for connections.");  }    public void handleMessageFromServerUI(String message)	{		if(message.startsWith("#"))		{			command(message.split(" "));		}		else		{						this.sendToAllClients("Server MSG > " + message);		}	}		public void command(String[] args)	{		String cmd = args[0].substring(1, args[0].length());		switch(cmd)		{		case "quit":		{			this.sendToAllClients("#logoff");			try {				this.close();			} catch (IOException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}			System.exit(0);			break;		}		case "stop":		{			this.stopListening();			System.out.println("[console] Server listening stopped");			sendToAllClients("[server] Stopped listening for new clients");			break;		}		case "close":		{			try {				this.sendToAllClients("[server] Closing...");				this.sendToAllClients("#logoff");				this.close();				System.out.println(" Server stopped");			} catch (IOException e) {}			break;		}		case "setport":		{			if(this.isListening())			{				System.out.println(" Error : cannot set port if server is listening");			}			else			{				int port = Integer.valueOf(args[1]);				this.setPort(port);				if(args.length == 2)				{					System.out.println(" Port has been set to " + args[1]);				}				else				{					System.out.println(" Port has been set to " + args[1] + ", others arguments have been ignored.");				}			}			break;		}		case "start":		{			if(this.isListening())			{				System.out.println("[console] Error : server already started");			}			else			{				try {					this.listen();					System.out.println("[console] : Server started");				} catch (IOException e) {					System.err.println("[console] Error : cannot listen for clients");				}			}			break;		}		case "getport":		{			System.out.println("[console] Server listening on port " + this.getPort());			break;		}		default:		{			System.out.println("[console] Error : unknown command");		}		}	}  	  /**	   * This method handles any messages received from the client.	   *	   * @param msg The message received from the client.	   * @param client The connection from which the message originated.	   */		public void handleMessageFromClient	(Object msg, ConnectionToClient client)	{		if(msg.toString().startsWith("#"))		{			parseClientCommand(msg.toString().split(" "), client);		}		else		{			if(client.getInfo("name") == null)			{				try {					client.sendToClient("[server] Error : username not known, connection refused");									client.close();				} catch (IOException e) {}			}			else			{				System.out.println("Message received: " + msg + " from " + client);				this.sendToAllClients("[" + client.getInfo("name") + "] " + msg);			}		}		}		protected void parseClientCommand(String[] args, ConnectionToClient client)	{		String cmd = args[0].substring(1, args[0].length());				switch(cmd)		{		case "login":		{			if(client.getInfo("name") == null)			{				client.setInfo("name", args[1]);				serverUI.display("[console] " + client.getInfo("name").toString() + " is connected");				this.sendToAllClients("[server] " + client.getInfo("name").toString() + " is connected");			}			else			{				try {					client.sendToClient("[server] Error : name already set");				} catch (IOException e) {}			}			break;		}		case "logoff":		{			try {				client.close();				serverUI.display("[console] " + client.getInfo("name") + " is disconnected");				this.sendToAllClients("[" + client.getInfo("name") + "] is disconnected");			} catch (IOException e) {}		}		}	}		 }//End of EchoServer class